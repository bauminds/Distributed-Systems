Assignment overiview:
In project 1, we implemented communication between server and client through sockets using TCP and UDP protocols. In project 2, RPC allows a calling process to call a procedure in a remote node as if it is local. By communicating with RPC, the project enables client programs to call procedures transparently in server programs running in separate processes and in different computers from the client. Also with RMI, we could invoke object references in different procedures. This assignment required other RPC frameworks. I used thrift to implement RPC. The purpose of the assignment in my personal view was to get us familiar with remote procedure calls between client and server, choose a framework, figure out its configuration, learn about its IDL and study by implementing the project.

Technical impression:
It took some unexpected time for me to successfully install and compile thrift. At first I tried to follow the tutorial on thrift’s official website but a lot of errors came out. For instance, though bison was updated, thrift links to the default 2.3 version along with Mac’s system; openssl file could not be found. Finally I successfully installed thrift with brew. I learned about gradle, the build tools which saves time for programmers to import thrift libraries. Though the configuration requires knowledge of computer systems and I had to consult other classmates. After studied thrift’s data types, services, definitions and syntax, which are rather obvious to understand, I found thrift is a very useful tool to implement communication of RPC between server and client. It can handle single thread, multi-thread situations and we don’t have to deal with data packets like we used to when implementing communication with sockets using TCP and UDP. The process was done in its own IDL. The structure of building connection between client and server was pretty clear as well. 

Except for KeyValueStore.thrift file, there are three main files in my project in total: client.java, server.java and KeyValueStoreHandler.java. KeyValueStore.thrift file is a definition thrift file that contains data types, structs and services, which in my case only contains methods implemented in server.java. In client.java file, I imported needed packages, dealt with input arguments, then created sockets for communication. I open the socket, pre-populated values, closed the socket and then wait for input. When received input, first evaluate the validity of the input arguments, if valid, choose an operation based on the input and invoke the methods implemented in server.java. After communication, close the socket, or else, catch any exception that occur in the steps above. KeyValueStore.java file was generated based on KeyValueStore.thrift file, using thrift -r —gen java KeyValueStore.thrift command, which includes the according Iface interface that has all the methods declared and implemented in server.java, and classes like Processor class that we need in server.java. KeyValueStore.thrift file is used as input and the compiler generates code to be used to easily build RPC clients and servers that communicate seamlessly across programming languages, which is very convenient.

In server.java, first get the input port number, create handler and processor instance, create multiple threads when required.

KeyValueStoreHandler.java is the actual file where all the methods are implemented.

Getting to learn about thrift, gradle and to implement the requirements were fun, but the environment configuration took unexpected time, which reminds me that I should work on my knowledge of computer systems and get a better grasp of it.